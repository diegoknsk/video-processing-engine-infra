---
description: Regras de infraestrutura (Terraform, Kubernetes, AWS)
alwaysApply: true
---

üß© Regras gerais deste reposit√≥rio (Infra / Terraform / Kubernetes)

Este reposit√≥rio √© respons√°vel por infraestrutura, n√£o por l√≥gica de neg√≥cio.

Tudo que for criado na cloud deve ser descrito em Terraform ou em manifestos Kubernetes ‚Äì nada de "ajeitar no console" sem voltar para o c√≥digo.

Manter o padr√£o de organiza√ß√£o atual:

- Infra AWS: diret√≥rio `terraform/`
- Manifests Kubernetes: diret√≥rio `k8s/` (subpastas `app/` e `infra/`)

Sempre que copiar algo de outro projeto, adaptar nomes, vari√°veis e coment√°rios para o contexto atual.

=====================
0. AUTENTICA√á√ÉO NA AWS
=====================

**Regra obrigat√≥ria:** toda intera√ß√£o com a AWS (Terraform, AWS CLI, pipelines) deve usar credenciais expl√≠citas e nunca hardcoded no c√≥digo.

0.1. Autentica√ß√£o via Access Key, Secret Key e Session Token

Para execu√ß√£o local (desenvolvimento, testes) e em pipelines que n√£o assumem role:

- **Access Key ID** (`AWS_ACCESS_KEY_ID`): identificador da credencial.
- **Secret Access Key** (`AWS_SECRET_ACCESS_KEY`): chave secreta.
- **Session Token** (`AWS_SESSION_TOKEN`): token de sess√£o (obrigat√≥rio quando as credenciais s√£o tempor√°rias, ex.: AWS Academy, SSO, assumed role).

Vari√°veis de ambiente obrigat√≥rias ao usar credenciais tempor√°rias:

```bash
export AWS_ACCESS_KEY_ID="<sua-access-key-id>"
export AWS_SECRET_ACCESS_KEY="<sua-secret-access-key>"
export AWS_SESSION_TOKEN="<seu-session-token>"
export AWS_REGION="<regi√£o>"
```

- Nunca commitar Access Key ID, Secret Access Key ou Session Token em arquivos do reposit√≥rio.
- N√£o definir credenciais em arquivos `.tf` ou em `backend` config com valores literais.
- Preferir vari√°veis de ambiente ou arquivo de perfil (`~/.aws/credentials`) fora do versionamento.
- Em CI/CD, usar secrets do pipeline (GitHub Secrets, GitLab CI variables, etc.) para injetar essas vari√°veis.

0.2. Credenciais tempor√°rias (AWS Academy / SSO)

Em ambientes como **AWS Academy**, as credenciais s√£o tempor√°rias e incluem Session Token. O token expira; renove as credenciais pelo portal da Academy antes de rodar `terraform plan/apply` ou pipelines.

- Sempre que usar credenciais da Academy, garantir que `AWS_SESSION_TOKEN` est√° definido.
- Se o comando falhar com erro de credenciais expiradas, atualizar as tr√™s vari√°veis (Access Key ID, Secret Access Key, Session Token) e executar novamente.

**Regra obrigat√≥ria:** em ambiente **AWS Academy**, a cria√ß√£o de v√°rios componentes (EKS cluster, Node Groups, ECR, etc.) exige que o Terraform use a **Lab Role** fornecida pela Academy. O aluno n√£o cria recursos com a identidade direta do usu√°rio; a Lab Role √© quem possui as permiss√µes necess√°rias.

0.3. Lab Role ‚Äì Cria√ß√£o de componentes (AWS Academy)

- **Lab Role** (`var.lab_role`): ARN da role que o Terraform usa para criar e gerenciar recursos (EKS, EKS Node Group, etc.). Deve ser **recebida como par√¢metro** (vari√°vel ou vari√°vel de ambiente) e nunca hardcoded.
- **Principal ARN** (`var.principal_arn`): ARN do principal (usu√°rio ou role do aluno) que ter√° acesso ao cluster EKS via EKS Access Entry.
- **Policy ARN** (`var.policy_arn`): ARN da policy de acesso ao EKS (ex.: `AmazonEKSClusterAdminPolicy`) associada ao principal.

0.4. Obriga√ß√µes

- Antes de rodar `terraform plan` ou `terraform apply`, garantir que:
  1. Voc√™ est√° autenticado (Access Key ID, Secret Access Key e, se aplic√°vel, Session Token), conforme se√ß√£o 0.1.
  2. A vari√°vel **lab_role** est√° definida (tfvars, vari√°vel de ambiente ou pipeline) com o ARN da Lab Role fornecida pela AWS Academy.
- Recursos que **devem** usar `var.lab_role`:
  - `aws_eks_cluster`: `role_arn = var.lab_role`
  - `aws_eks_node_group`: `node_role_arn = var.lab_role`
- Acesso ao cluster (quem pode usar o cluster):
  - Usar `aws_eks_access_entry` e `aws_eks_access_policy_association` com `principal_arn = var.principal_arn` e `policy_arn = var.policy_arn`.
- Nunca hardcodear o ARN da Lab Role nem do principal nos arquivos `.tf`; sempre usar vari√°veis (ex.: `var.lab_role`, `var.principal_arn`).

=====================
1. REGRAS DE TERRAFORM
=====================

1.1. Vers√£o e providers

- Usar bloco `terraform` com `required_version >= "1.0"`.
- Usar o provider AWS da fam√≠lia `~> 5.0` (ou vers√£o est√°vel atual).
- Provider principal: regi√£o sempre parametrizada, nunca hardcoded.

```hcl
provider "aws" {
  region = var.aws_region
}
```

1.2. Backend remoto (state) ‚Äì boas pr√°ticas DevOps

- Backend deve ser **sempre S3**, nunca local.
- O arquivo `backend.tf` √© o dono √∫nico da configura√ß√£o do backend.
- Habilitar **state locking** com DynamoDB para evitar conflitos em execu√ß√µes paralelas (recomendado em equipe e CI/CD).
- N√£o commitar: `*.tfstate`, `*.tfstate.backup`, `.terraform/`, arquivos `.tfplan`.
- N√£o alterar bucket ou key do state sem planejamento; garantir que o bucket (e a tabela DynamoDB, se usar lock) exista antes de `terraform init`.

Exemplo de backend com lock:

```hcl
terraform {
  backend "s3" {
    bucket         = "nome-do-bucket-state"
    key            = "ambiente/terraform.tfstate"
    region         = "us-east-1"
    dynamodb_table = "terraform-state-lock"
    encrypt        = true
  }
}
```

1.3. Organiza√ß√£o de arquivos

Um arquivo por responsabilidade:

- `providers.tf` ‚Üí vers√£o do Terraform e provider AWS
- `backend.tf` ‚Üí configura√ß√£o do backend S3 (e lock se aplic√°vel)
- `datasource.tf` ‚Üí `data "aws_*"` e helpers de descoberta
- `network.tf` ‚Üí VPC e subnets
- `sg.tf` ‚Üí Security Groups principais
- `eks-cluster.tf` ‚Üí `aws_eks_cluster`
- `eks-node.tf` ‚Üí `aws_eks_node_group`
- `eks-access-policy.tf` / `access-entry.tf` ‚Üí acesso ao cluster (IAM/EKS)
- `ecr.tf` ‚Üí reposit√≥rios ECR
- `network-rds.tf` ‚Üí regras SG entre EKS e RDS (quando aplic√°vel)
- `variables.tf` ‚Üí vari√°veis de entrada
- `outputs.tf` ‚Üí outputs p√∫blicos
- `locals.tf` ‚Üí locals (evitar valores sens√≠veis)

Para novos recursos: `network-*.tf`, `sg-*.tf`, `monitoring-*.tf`, etc. Evitar arquivos √∫nicos com centenas de linhas.

1.4. Vari√°veis, nomes e tags

Parametrizar por ambiente: `project_name`, `env`, `aws_region`, `lab_role`, `policy_arn`, `principal_arn`.

Padr√£o de nomes:

```hcl
name = "${var.project_name}-api"
name = "eks-${var.project_name}"
node_group_name = "nodeg-${var.project_name}"
```

Tags m√≠nimas em todos os recursos suportados:

```hcl
tags = {
  Name        = "${var.project_name}-<recurso>"
  Environment = var.env
  Project     = var.project_name
}
```

1.5. Uso da Lab Role (EKS e Node Group)

- N√£o criar novas roles "admin" no Terraform; usar a Lab Role fornecida (se√ß√£o 0).
- EKS: `role_arn = var.lab_role`.
- Node Group: `node_role_arn = var.lab_role`.
- Acesso ao cluster: `aws_eks_access_entry` + `aws_eks_access_policy_association` com `cluster_name`, `policy_arn`, `principal_arn` via vari√°veis.

1.6. VPC e subnets

- Usar VPC default quando o contexto permitir (ex.: AWS Academy):

```hcl
data "aws_vpc" "default" { default = true }
```

- Subnets: descobrir via `data "aws_subnets"` filtrando pela VPC e AZs permitidas.
- Excluir AZs n√£o suportadas no ambiente (ex.: `us-east-1e` no Academy) quando necess√°rio.
- N√£o criar VPC nova se o ambiente (ex.: Academy) restringir ou se n√£o for requisito.

1.7. Security Groups

- SG principal: expor apenas portas necess√°rias (ex.: 80, 443). Egress 0.0.0.0/0 √© aceit√°vel para MVP; n√£o abrir ingress desnecess√°rio.
- EKS ‚Üî RDS: regras em arquivo dedicado (ex.: `network-rds.tf`), restringindo por SG do EKS e SG do RDS. Nunca abrir RDS para 0.0.0.0/0. Portas: MySQL 3306, PostgreSQL 5432.

1.8. Cluster EKS e Node Group

- Cluster: `role_arn = var.lab_role`, `version` e `vpc_config` parametrizados.
- Node Group: `node_role_arn = var.lab_role`, `scaling_config` (min/desired/max), `update_config { max_unavailable = 1 }`, `instance_types` via vari√°vel.

1.9. ECR

- Usar feature flag (ex.: `var.manage_ecr`) para criar ou n√£o reposit√≥rios.
- ECR: `image_tag_mutability = "MUTABLE"`, `image_scanning_configuration { scan_on_push = true }`, `force_delete = true` em lab, lifecycle policy para expirar imagens antigas. Nomes: `${var.project_name}-<sufixo>`.

1.10. Data sources e outputs

- Evitar IDs hardcoded; usar `data "aws_*"` quando poss√≠vel.
- Outputs: apenas o necess√°rio para kubeconfig, pipelines e integra√ß√£o (ex.: `eks_name`, `eks_endpoint`, `eks_ca`, URLs ECR).

1.11. Boas pr√°ticas DevOps (Terraform)

- **Idempot√™ncia:** m√∫ltiplas execu√ß√µes de `terraform apply` com o mesmo estado n√£o devem criar recursos duplicados.
- **Estado remoto e lock:** sempre S3 + DynamoDB (ou equivalente) em ambiente compartilhado.
- **Sem segredos no c√≥digo:** nenhuma senha, token ou connection string em `.tf`; usar Secrets Manager ou vari√°veis de ambiente nos pipelines e injetar em Kubernetes Secret.
- **Valida√ß√£o antes de commit:**
  1. `terraform init` (se houver mudan√ßa de m√≥dulos/backend)
  2. `terraform fmt -recursive`
  3. `terraform validate` ‚Üí deve retornar "Success! The configuration is valid."
- N√£o commitar c√≥digo com `terraform validate` falhando.
- Opcional: em CI, rodar `terraform plan` e revisar mudan√ßas antes de apply.

=====================
2. REGRAS DE KUBERNETES (manifests em /k8s)
=====================

2.1. Organiza√ß√£o

- Aplica√ß√µes: `k8s/app/<servi√ßo>/` (ex.: `api-deployment.yaml`, `api-service.yaml`, `api-hpa.yaml`).
- Infra compartilhada: `k8s/infra/` (namespace, configmap, metrics, etc.).

2.2. Namespaces

- N√£o usar o namespace `default` para aplica√ß√µes do projeto.
- Usar Namespace expl√≠cito (ex.: `namespace.yaml`) com nome claro por contexto (ex.: orderhub, paystream, kitchenflow).

2.3. Deployments

- `kind: Deployment`, `strategy: RollingUpdate` (ex.: `maxUnavailable: 0`, `maxSurge: 1`).
- `spec.selector.matchLabels` = `spec.template.metadata.labels`.
- Imagem da aplica√ß√£o principal a partir de ECR (n√£o Docker Hub p√∫blico para produ√ß√£o).
- Container: `ports.containerPort` nomeado (ex.: `name: http`), `resources.requests` e `resources.limits` definidos.
- Config n√£o sens√≠vel: `envFrom.configMapRef`; sens√≠vel: `envFrom.secretRef`.

2.4. Services

- Uma aplica√ß√£o exposta = um Service. LoadBalancer com annotations NLB quando em AWS (internet-facing, nlb). `spec.selector` alinhado ao Deployment.

2.5. HPA

- API `autoscaling/v2`, m√©trica de CPU (e opcionalmente mem√≥ria). `minReplicas >= 2` quando alta disponibilidade for requisito; `maxReplicas` coerente com capacidade do cluster.

2.6. ConfigMaps e Secrets

- **ConfigMap:** apenas dados n√£o sens√≠veis (URLs, issuer, audience, timeouts, nomes).
- **Secret:** senhas, connection strings, tokens, chaves. Nunca commitar valores reais; usar placeholders ou inje√ß√£o via pipeline.

=====================
3. AUTENTICA√á√ÉO E ACESSO (resumo)
=====================

- **Terraform / CLI:** autenticar com Access Key ID, Secret Access Key e Session Token (vari√°veis de ambiente ou perfil), conforme se√ß√£o 0.1.
- **Cria√ß√£o de recursos (AWS Academy):** usar Lab Role em `var.lab_role`; nunca hardcodear ARNs (se√ß√£o 0.3‚Äì0.4).
- **Acesso ao EKS:** `aws eks update-kubeconfig --name <eks_name> --region <region> --role-arn <lab_role>`; preferir EKS Access Entry em vez de editar `aws-auth` manualmente.
- **Tokens de aplica√ß√£o (JWT/Cognito):** Terraform n√£o gerencia; apenas prover infra. Em Kubernetes: config em ConfigMap, segredos em Secret.

=====================
4. DEFINI√á√ÉO DE "FEITO" PARA MUDAN√áAS DE INFRA
=====================

Considerar a mudan√ßa conclu√≠da somente se:

- `terraform fmt -recursive` e `terraform validate` executados sem erro.
- `terraform init` executado quando houver mudan√ßa de m√≥dulos/backend.
- Nomes e tags seguindo o padr√£o; seguran√ßa m√≠nima (nada exposto desnecessariamente).
- Manifests com namespace correto; Deployment + Service + HPA quando aplic√°vel; ConfigMap vs Secret usados corretamente.
- Nenhuma credencial (Access Key, Secret, Token, Lab Role ARN literal) commitada em `.tf` ou `.yaml`.
